## 도메인 모델 만들기
### 중요 변경사항
#### 1. 상품 옵션 → 상품 변형(ProductVariant)으로 확장
기존의 단순한 `ProductOption`에서 완전한 상품 변형 모델로 발전:
- 각 변형은 고유한 SKU를 가짐
- 개별 가격 설정 가능
- 개별 상태 관리 가능
- 재고와 연동 가능한 구조

#### 2. 상품 상태 변경
- `ON_SALE`, , `STOPPED` → `ACTIVE`, `INACTIVE`로 단순화 `OUT_OF_STOCK`
- `DELETED` 상태는 별도 `isDeleted` 필드로 관리

#### 3. 애그리거트 패턴 적용
- Product가 애그리거트 루트 역할
- ProductVariant는 애그리거트 내부 엔티티
- 모든 변형 관련 작업은 Product를 통해서만 수행
---
### 상품(Product)

*Entity*

판매자가 상품을 등록하고

구매자가 상품을 구매한다

### 속성

- `id` : 상품ID (String, UUID 전략 사용)
- `sellerId` : 판매자ID
- `name` : 상품명
- : 브랜드명 `brand`
- `description` : 상품설명
- : 카테고리ID `categoryId`
- : 기본 상품가격 ( - @Embedded 사용) `basePrice` `ProductMoney`
- `status` : 상품 상태 () `ProductStatus`
- `isDeleted` : 상품 삭제 상태 (Boolean)
- : 삭제일 (LocalDateTime) `deletedAt`
- `createdAt` : 생성일 (LocalDateTime)
- `updatedAt` : 수정일 (LocalDateTime)
- `variants` : 상품 변형들 (`List<ProductVariant>` - @OneToMany 사용)
---
### 행위

- `static create(ProductCreateRequest)` : 상품을 등록한다 → 상품 상태가 ACTIVE
- `updateInfo(ProductInfoUpdateRequest)` : 상품 정보를 수정한다
- `activate()` : 상품을 활성화한다
- `inactivate()` : 상품을 비활성화한다
- `changeCategory(String categoryId)` : 카테고리를 변경한다
- `changePrice(ProductMoney newPrice)` : 기본 가격을 변경한다
- `changeStatus(ProductStatus newStatus)` : 상태를 변경한다 (변형 상품들에도 영향)
- `delete()` : 상품을 삭제한다 (논리 삭제)
- `addVariant(Map<String, String>, ProductMoney)` : 단일 변형을 추가한다
- `addVariants(List<ProductVariantRequest>)` : 복수 변형을 추가한다
- `updateVariant(String sku, ProductVariantUpdateRequest)` : 변형을 수정한다
- `removeVariant(String sku)` : 변형을 제거한다
- `updateVariantPrice(String sku, ProductMoney)` : 변형 가격을 변경한다
- `changeVariantStatus(String sku, VariantStatus)` : 변형 상태를 변경한다
- `findVariantBySku(String sku)` : SKU로 변형을 찾는다
- `getAvailableVariants()` : 구매 가능한 변형들을 조회한다
- `handleStockStatusChanged(String sku)` : 재고 상태 변경 이벤트를 처리한다


---

<aside>
💡

하나의 값 객체거나, 충분히 도메인으로 성숙해질 가능성이 있는 필드는 별도로 관리

- 상품 가격 → 상품에 종속되어 있는 것 처럼 보이지만, 각종 지역 통화 규격이나 할인 정책 등이 반영될 가능성이 큼
  → 그랬을 때 필드로 존재한다면 필연적으로 절차적으로 짜질 수 있다.
</aside>

### 규칙 (Invariant 불변성) 반드시 지켜져야 할 것들
#### 비기능적인 요구사항이 규칙처럼 들어가는 경우가 많은데, 사실 구분하기가 굉장히 어려움 → 그냥 되는대로 하는게 맞음

- 상품 등록 시 기본 상태는 ON_SALE이다
- 판매자는 본인의 상품만 수정/삭제 가능하다
- 상품 삭제는 STOPPED 상태에서만 가능하다
- ON_SALE 상태 에서만 STOPPED가 가능하다
- OUT_OF_STOCK 상태가 아닌 상품만 ON_SALE 변경 가능하다
- 지금과 같은 카테고리로는 변경할 수 없다.

### 상품 상태 ProductStatus
_Enum_
- `ACTIVE` : 활성 상태 (판매 가능)
- `INACTIVE` : 비활성 상태 (판매 중지)

### 상품가격 ProductMoney

*VO*

금액과 통화를 한 단위로 묶어서 비즈니스 규칙 누락 위험을 제거하고자 넣었는데, 굳이 필요없으면 뺴도 될 것 같아요!

예) 가격 관련 연산(결제, 주문,.. )

- `amount`
- `currency`

```java
@Embeddable
  public class ProductMoney {
  private BigDecimal amount;
  private String currency;

  // 팩토리 메서드
  public static ProductMoney of(BigDecimal amount, String currency);
  }
```
---

도메인 로직 ≠ 비즈니스 로직
두 로직을 잘 분리하자.
도메인에 대한 탐구는 도메인 모델 로직과, 어플리케이션 로직의 분리를 얼마나 잘 했느냐도 중요함

### 상품변형 ProductVariant
_Entity (애그리거트 내부)_
- `id` : 변형 ID
- : 상품 ID (FK) `productId`
- `sellerId` : 판매자 ID
- : 재고 관리 단위 코드 `sku`
- : 옵션 조합 (JSON) `optionCombination`
- : 판매 가격 `sellingPrice`
- `status` : 변형 상태
- `createdAt`, `updatedAt` : 생성/수정일

### 규칙 (Invariant 불변성)
- 상품 등록 시 기본 상태는 ACTIVE이다
- 판매자는 본인의 상품만 수정/삭제 가능하다
- 상품이 INACTIVE 상태일 때만 삭제 가능하다
- 상품 상태 변경 시 모든 변형의 상태도 함께 변경된다
- 중복된 SKU는 생성할 수 없다
- 변형 추가는 상품이 저장된 후에만 가능하다

### 변형 상태 VariantStatus
_Enum_
- `ACTIVE` : 활성 상태
- `INACTIVE` : 비활성 상태
- : 품절 `OUT_OF_STOCK`
- : 단종 `DISCONTINUED`