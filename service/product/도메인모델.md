## 도메인 모델 만들기

### 상품(Product)

*Entity*

판매자가 상품을 등록하고

구매자가 상품을 구매한다

### 속성

- -`id` : 상품ID
- -`sellerId` : 판매자ID
- -`name` : 상품명
- -`brand` : 브랜드명
- -`description` : 상품설명
- -`categoryId` : 카테고리ID
- -`price` : 상품가격 (`ProductMoney` - @Embedded 사용)
- -`options` : 상품 옵션들 (`List<ProductOption>` - @ElementCollection, @CollectionTable 사용)
- -`status` : 상품 상태
- -`deleteYn` :  상품 삭제 상태
- -`createdAt` : 생성일
- -`updatedAt` : 수정일
- `deletedAt`: 삭제일

---


### 행위

- +`static create()` : 등록한다 → 상품 상태가 ON_SALE
- +`static update()` : 수정한다 → 상품 정보(디테일)에 대한 변경
- +`changeCategory()` : 카테고리를 변경한다.
- +`changeProductStopped()` : 판매 중지로 만들 수 있다 → 상품 상태가 STOPPED
- +`deleteProduct()`: 삭제한다.  상품 상태가 DELETED
- +`changePrice()` : 가격을 변경한다
- -`changeStatus()` : 상태를 변경한다
- … 그 외의 변경 관련된 모든 것

---

<aside>
💡

하나의 값 객체거나, 충분히 도메인으로 성숙해질 가능성이 있는 필드는 별도로 관리

- 상품 가격 → 상품에 종속되어 있는 것 처럼 보이지만, 각종 지역 통화 규격이나 할인 정책 등이 반영될 가능성이 큼
  → 그랬을 때 필드로 존재한다면 필연적으로 절차적으로 짜질 수 있다.
</aside>

### 규칙 (Invariant 불변성) 반드시 지켜져야 할 것들
#### 비기능적인 요구사항이 규칙처럼 들어가는 경우가 많은데, 사실 구분하기가 굉장히 어려움 → 그냥 되는대로 하는게 맞음

- 상품 등록 시 기본 상태는 ON_SALE이다
- 판매자는 본인의 상품만 수정/삭제 가능하다
- 상품 삭제는 STOPPED 상태에서만 가능하다
- ON_SALE 상태 에서만 STOPPED가 가능하다
- OUT_OF_STOCK 상태가 아닌 상품만 ON_SALE 변경 가능하다
- 지금과 같은 카테고리로는 변경할 수 없다.

### 상풍 상태 ProductStatus

*Enum*

- `ON_SALE` : 판매중
- `OUT_OF_STOCK` : 품절
- `STOPPED` : 판매중지

### 상품가격 ProductMoney

*VO*

금액과 통화를 한 단위로 묶어서 비즈니스 규칙 누락 위험을 제거하고자 넣었는데, 굳이 필요없으면 뺴도 될 것 같아요!

예) 가격 관련 연산(결제, 주문,.. )

- `amount`
- `currency`

### 상품옵션 ProductOption

*VO*

- `name`
- `value`

### 소스 예시

```java
@Entity
public class Product {
	@Id
	private Long id;
	private String name;
	...
	
	@Embedded
	private ProductMoney price;
	@ElementCollection
	@CollectionTable(
		name = "product_option",
		joinColumns = @JoinColumn(name = "product_id")
	)
	private List<ProductOption> options = new ArrayList<>();
	...
}

@Embeddable
public class ProductMoney {
	private BigDecimal amount;
	private String currency;
}

@Embeddable
public class ProductOption {
	private String name; // "color", "size"
	private String value; // "black", "M" 
	
	protected ProductOption(){};
	
	public ProductOption(String name, String value) {
		this.name = name;
		this.value = value;
	}
	
}
```


도메인 로직 ≠ 비즈니스 로직
두 로직을 잘 분리하자.
도메인에 대한 탐구는 도메인 모델 로직과, 어플리케이션 로직의 분리를 얼마나 잘 했느냐도 중요함
